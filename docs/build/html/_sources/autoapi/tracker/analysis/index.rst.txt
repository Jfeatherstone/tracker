tracker.analysis
================

.. py:module:: tracker.analysis


Functions
---------

.. autoapisummary::

   tracker.analysis.autocorrelation
   tracker.analysis.computeAngles
   tracker.analysis.exponential
   tracker.analysis.computeRotationalDiffusion
   tracker.analysis.computePersistence
   tracker.analysis.computeMSD


Module Contents
---------------

.. py:function:: autocorrelation(x, minLag=0, maxLag=100, dt=1, dtau=1, normalize=True)

   
   Compute the autocorrelation of some vector.

   :math:`\langle x(t) x(t + \tau) \rangle`

   :Parameters:

       **x** : numpy.ndarray[N]
           The vector to compute the autocorrelation for.

       **minLag** : float
           The minimum lag to compute, in the same units as `dt`.

       **maxLag** : float
           The maximum lag to compute, in the same units as `dt`.

       **dt** : float
           The time difference between each point in `x`.

       **dtau** : float
           The interval at which to sample the autocorrelation, in the same
           units as `dt`.

       **normalize** : bool
           Whether to normalize the autocorrelation values by the first
           entry.



   :Returns:

       **lagArr** : numpy.ndarray[M]
           The time lags for which the autocorrelation is computed.

       **autocorr** : numpy.ndarray[M]
           The autocorrelation at each time lag.











   ..
       !! processed by numpydoc !!

.. py:function:: computeAngles(trajectory, dt=1, minVelocityThreshold=0)

   
   Compute the angle difference (turn angles) throughout a 2D trajectory.

   This does not necessarily maintain the same indexing as the input trajectory,
   since it is primarily for compute distributions and statistics.

   :Parameters:

       **trajectory** : numpy.ndarray[N,2]
           The trajectory to compute the angles for.

       **dt** : float, optional
           The time different between each point in the trajectory. Used to compute
           the velocity and threshold based on ``minVelocityThreshold``.

       **minVelocityThreshold** : float, optional
           The velocity threshold below which an angle won't be included in
           the final array of angles. Useful since you may see huge angle changes
           which are actually just jitter if the trajectory remains (nearly) stationary
           for some period of time.



   :Returns:

       **angles** : numpy.ndarray[M]
           All of the (valid) turn angles throughout the trajectory.











   ..
       !! processed by numpydoc !!

.. py:function:: exponential(x, x0, A)

   
   Exponential function used in fitting the rotational diffusion and/or
   persistence time.
















   ..
       !! processed by numpydoc !!

.. py:function:: computeRotationalDiffusion(trajectory, c, v, minStepsPerRun, minDistancePerRun, t=None, minLag=0, maxLag=2, dtau=0.1)

   
   Compute the rotational diffusion coefficient, assuming
   that the trajectory data follows a run-and-tumble scheme.

   This is done by discretizing the trajectory as a run-and-tumble,
   then computing the autocorrelation of just the runs. Since each
   individual run might not have enough data to fit by itself, the
   data from all runs are pooled together.

   :Parameters:

       **trajectory** : numpy.ndarray[N,2] or list of numpy.ndarray[N,2]
           The trajectory to compute the rotational diffusion coefficient
           for.
           
           Can also be a list of disjoint segments representing the same
           trajectory (for example, if there are gaps in a trajectory that
           should be avoided in calculate the persistence, but you want
           to average over the entire collection of segments).

       **theta** : float
           The angle threshold parameter used for discretizing the
           trajectory, in radians.

       **v** : float
           The velocity threshold parameter used for discretizing the
           trajectory.

       **minStepsPerRun** : int
           The minimum number of steps per run for discretizing the
           trajectory.

       **minDistancePerRun** : float
           The minimum distance per run for discretizing the
           trajectory. Given in whatever units ``trajectory`` is given in.

       **t** : float or numpy.ndarray[N,2] or list of numpy.ndarray[N,2], optional
           The time points at which the data is sampled. If all samples are
           evenly spaced, can be a single float representing the time difference.
           
           If ``trajectory`` is given as a list of segments, this should be structured
           similarly.
           
           If not given, all samples will be assumed to be spaced evenly, and ``v`` will
           be given in units of distance/frames (where the distance unit is whatever
           the units of ``trajectory`` are.

       **minLag** : float
           The minimum time lag to compute the autocorrelation for, given in the
           same units as ``t``.

       **maxLag** : float
           The max time lag to compute the autocorrelation for, given in the same units as ``t``.

       **dtau** : float
           The spacing between sampled time lags to compute the rotational diffusion
           using, given in the same units as ``t``.



   :Returns:

       **Dr** : float or numpy.nan
           The rotational diffusion coefficient computed by pooling the autocorrelation
           data for all of the trajectories. If fitting failed or some other issue
           arose, ``np.nan`` will be returned.











   ..
       !! processed by numpydoc !!

.. py:function:: computePersistence(trajectory, v, t=None, minLag=0, maxLag=2, dtau=0.1)

   
   Compute the rotational diffusion coefficient, assuming
   that the trajectory data follows a run-and-tumble scheme.

   This is done by discretizing the trajectory as a run-and-tumble,
   then computing the autocorrelation of just the runs. Since each
   individual run might not have enough data to fit by itself, the
   data from all runs are pooled together.

   :Parameters:

       **trajectory** : numpy.ndarray[N,2] or list of numpy.ndarray[N,2]
           The trajectory to compute the rotational diffusion coefficient
           for.
           
           Can also be a list of disjoint segments representing the same
           trajectory (for example, if there are gaps in a trajectory that
           should be avoided in calculate the persistence, but you want
           to average over the entire collection of segments).

       **t** : float or numpy.ndarray[N,2] or list of numpy.ndarray[N,2], optional
           The time points at which the data is sampled. If all samples are
           evenly spaced, can be a single float representing the time difference.
           
           If ``trajectory`` is given as a list of segments, this should be structured
           similarly.
           
           If not given, all samples will be assumed to be spaced evenly, and ``v`` will
           be given in units of distance/frames (where the distance unit is whatever
           the units of ``trajectory`` are.

       **minLag** : float
           The minimum time lag to compute the autocorrelation for, given in the
           same units as ``t``.

       **maxLag** : float
           The max time lag to compute the autocorrelation for, given in the same units as ``t``.

       **dtau** : float
           The spacing between sampled time lags to compute the rotational diffusion
           using, given in the same units as ``t``.



   :Returns:

       **persistence** : float or numpy.nan
           The persistence time computed by pooling the autocorrelation data for
           all of the trajectories. If fitting failed or some other issue arose,
           ``np.nan`` will be returned.











   ..
       !! processed by numpydoc !!

.. py:function:: computeMSD(trajectory, t=None, minLag=0, maxLag=30, nbins=30, logbins=True)

   
   Compute the mean-squared displacement of a trajectory as a function of
   the time lag between samples.

   Slightly more complicated than one might expect, since we might have
   time jumps in the sampling, and we want to be able to count those properly.

   :Parameters:

       **trajectory** : numpy.ndarray[N,2] or list of numpy.ndarray[N,2]
           The trajectory to compute the rotational diffusion coefficient
           for.
           
           Can also be a list of disjoint segments representing the same
           trajectory (for example, if there are gaps in a trajectory that
           should be avoided in calculate the persistence, but you want
           to average over the entire collection of segments).

       **t** : float or numpy.ndarray[N,2] or list of numpy.ndarray[N,2], optional
           The time points at which the data is sampled. If all samples are
           evenly spaced, can be a single float representing the time difference.
           
           If ``trajectory`` is given as a list of segments, this should be structured
           similarly.
           
           If not given, all samples will be assumed to be spaced evenly.

       **minLag** : float
           The minimum time lag to compute the MSD for, given in the
           same units as ``t``.

       **maxLag** : float
           The max time lag to compute the MSD for, given in the same units as ``t``.

       **nbins** : int
           The number of time lags to sample in the specified range.

       **logbins** : bool
           Whether to space the time lags linearly (False) or logarithmically
           (True).



   :Returns:

       **tArr** : numpy.ndarray[nbins]
           The time lags the MSD is computed for

       **msdArr** : numpy.ndarray[nbins]
           The MSD for each time lag, averaged across all trajectories provided.











   ..
       !! processed by numpydoc !!

